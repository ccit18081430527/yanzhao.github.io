# 概述
本节以用户图形界面为例进行详细说明，包括如何在LCD上通过LVGL实现用户自己需要的界面开发，如何通过FreeRTOS使LVGL线程安全，以及LVGL与屏幕互相影响互相依赖。
完整的示例参考jzw7258项目，路径位于AVDK/projects/jzw7258，config配置和main文件，涵盖了所需所有的配置，用户可按需更改，所有config宏定义都可在IDK/middleware/bk7258/soc/bk7258.defconfig 文件下找到。

和所有项目类似，从main主函数入口处查看程序处理逻辑，此项目下有创建线程、外设初始化等流程，并覆盖了CPU0和CPU1交叉处理的原理。简单来讲，开发板上电之后，程序先运行CPU0,再运行CPU1，但CPU1处理完后还需将消息发送到CPU0执行，其原理可参考FreeRTOS的AMP架构。

## LVGL实现
毋庸置疑的是 widgets_main.c 文件是主程序，其中关于LVGL实现的是 void lvgl_event_handle(media_mailbox_msg_t *msg) 和 static int media_ipc_lvgl_callback(uint8_t *data, uint32_t size, void *param) 这两个函数，已规定好CPU0和CPU1。对LVGL运行逻辑修改的内容如下
* 每个屏幕的分辨率不一样，对应的显示内存大小也不一样，规定显示内存为整内存的十分之一，计算公式如下。比如此屏幕是RGB888，则是24bit，换算字节为3Bytes。当RGB565时，则是16bit，但RGB666时，是18bit，换算之后为2.5Bytes，此种情况按2Bytes计算。
```plantuml
Xres * Yres * RGB(bit) / 8Bytes
```
* 具体代码修改如下：
```plantuml
lv_vnd_config.draw_pixel_size = (30 * 1024) / sizeof(lv_color_t);
```
* 屏幕旋转：LVGL有旋转参数可直接赋值 lv_vnd_config.rotation = ROTATE_90，关于LV_Vendor部分，位于LVGL接口驱动部分，与硬件做了无缝衔接，故修改LVGL即可，即是修改了硬件，无需再特意修改硬件的x,y坐标旋转屏幕处理。 
* 找到内部函数lv_demo_widgets()，为LVGL官方demo，这是LVGL界面显示逻辑程序。用户可再main文件夹下新建.c文件存放界面逻辑的实现，参考lv_demo_widgets()。而在此处的上下部分，还有lv_vendor的相关处理，这是线程为了稳定锁住LVGL的流程：LV_vendor初始化-锁LV-UI显示-解锁LV-启动LV。